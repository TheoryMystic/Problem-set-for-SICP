#lang racket
#|
1.2.3 Orders of Growth
|#

#|
Exercise 1.14
Draw the tree illustrating the process generated by the count-change procedure in making change for 11 cents
|#

#|
code : count-change
|#
(define (count-change amount) (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination
                         kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
#|
count change tree illustrating
|#
;; (count-change 11)

;; (cc 11 5)

;; (+ (cc 11 (- 5 1))
;;    (cc (- 11 50)) 5)

;; (+ (cc 11 4)
;;    (cc -39 5))

;; (+ (+ (cc 11 4)
;;       (cc (- 11 25) 4))
;;    0)

;; (+ (+ (+ (+ (cc 11 3)
;;             (cc (- 11 25) 4))
;;          0)
;;       0))

;; (+ (+ (+ (+ (+ (+ (cc 11 2)
;;                   (cc (- 11 10) 3))
;;                0)
;;           0))
;;     0))

;; (+ (+ (+ (+ (+ (+ (+ (+ (cc 11 1)
;;                         (cc (- 11 5) 2))
;;                      (cc 1 3))
;;                0))
;;           0))
;;     0))

;; (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (cc 11 0)
;;                               (cc (- 11 1) 1))))
;;                      (+ (cc 1 2)
;;                         (cc (- 1 10) 3)))
;;                0))
;;           0))
;;     0))

;; (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ 0
;;                               (cc 10 1))))
;;                      (+ (+ (cc 1 1)
;;                            (cc (- 1 2) 2))))
;;                0))
;;           0))
;;     0))

;; (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ 0
;;                               (+ (cc 10 0)
;;                                  (cc (- 10 1) 1)))))
;;                      (+ (+ (+ (cc 1 0)
;;                               (cc (- 1 1) 1))
;;                            (cc -1 2))))
;;                0))
;;           0))
;;     0))

;; (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ 0
;;                               (+ 0
;;                                  (cc 9 1)))))
;;                      (+ (+ (+ (cc 1 0)
;;                               1)
;;                            0)))
;;                0))
;;           0))
;;     0))

;; (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ 0
;;                               (+ 0
;;                                  (+ (cc 8 0)
;;                                     (cc (- 8 1) 1))))))
;;                      (+ (+ (+ 0
;;                               1)
;;                            0)))
;;                0))
;;           0))
;;     0))

;; (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ 0
;;                               (+ 0
;;                                  (+ 0
;;                                     (cc 7 1))))))
;;                      (+ (+ (+ 0
;;                               1)
;;                            0)))
;;                0))
;;           0))
;;     0))

;; .......... now I give up :(


#|
Exercise 1.15
x->0 => sin(x) ~= x
sin(x) = 3*sin(x/3)-4*(sin(x/3)^3)
|#
(define (cube x) (* x x x))
(define (p x) (- (* 3 x)
                 (* 4 (cube x))))
(define (sine angle)
  (if [not (> (abs angle) 0.1)]
      angle
      [p (sin (/ angle 3.0))]))
(sine 12.15) ;;-0.4044438228491407
(sine 3.14) ;;0.0015926529164871361 (0)
(sine 1.57) ;;0.9999996829318347 (pi/2)

#|
a. how many times is the procedure p applied when (sine 12.15) is evaluated?
|#

;; ((12.15/3.0) / 3.0) ... <= 0.1
;; n = 5
(define (div-countdown value div)
  (cond [(<= value 0.1) 0]
        [(+ 1
            (div-countdown (/ value div) div))]))
(div-countdown 12.15 3.0) ;;5

#|
b. what's the order of growth in space and number of steps(as a function of a) used by the process generated by the sine procedure when (sine a) is evaluated?
|#

;; space -> O(log(a))
;; number of steps -> O(log(a))
